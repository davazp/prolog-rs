use std::str::FromStr;

use crate::terms::{Name, Term, Variable} ;

grammar;

pub Program = Clause*;
Clause = <Expr> ".";
Query = <Expr> ".";

pub Expr = Rule1200;

XFY<Op,NextTier>: Term = {
    <l:XFY<Op,NextTier>> <op:Op> <r:NextTier> => Term::functor2(op, l, r),
    NextTier
};

Rule1200 = XFY<Op1200, Rule1000>;
Rule1200_arg = XFY<Op1200, Rule1000_arg>;
Op1200 = { ":-" };

Rule1000 = XFY<Op1000, Rule700>;
Rule1000_arg = Rule700;
Op1000 = { "," }

Rule700 = XFY<Op700, Rule500>;
Op700 = { "<", ">", "=", "<=", ">=" };

Rule500 = XFY<Op500, Rule400>;
Op500 = { "+", "-" };

Rule400 = XFY<Op400, ExprTerm>;
Op400 = { "*", "/" }

ExprTerm = {
    Name,
    Variable,
    AtomicFunctor,
    Functor,
    "(" <Expr> ")"
}

AtomicFunctor: Term =
    Identifier => Term::Functor{ name: <>, args: vec![] };

Functor: Term =
    <i:FunctorName> <args:(<FunctorArg> ","?)+> ")" => Term::Functor { name: i, args: args };

FunctorArg: Term = Rule700;

Name: Term = Num => Term::Integer(<>);

FunctorName: Name = r"[a-z][_A-Za-z0-9]*\(" => Name(<>.to_string());
Identifier: Name = r"[a-z][_A-Za-z0-9]*" => Name(<>.to_string());
Variable: Term = r"[_A-Z][_A-Za-z0-9]*" => Term::Var(Variable(<>.to_string()));

Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
