// -*- rust -*-

use std::str::FromStr;

use crate::terms::{Functor, Atom, Term, Variable} ;

grammar;

pub Program = Clause*;
Clause = <Expr> ".";
pub Query = <Expr> ".";
pub Queries = Query*;

pub Expr = Rule1200;
Expr_arg = Rule1200_arg;

XFY<Op,NextTier>: Term = {
    <l:XFY<Op,NextTier>> <op:Op> <r:NextTier> => Term::functor2(op, l, r),
    NextTier
};

Rule1200 = XFY<Op1200, Rule1000>;
Rule1200_arg = XFY<Op1200, Rule1000_arg>;
Op1200 = { ":-" };

Rule1000 = XFY<Op1000, Rule700>;
Rule1000_arg = Rule700;
Op1000 = { "," }

Rule700 = XFY<Op700, Rule500>;
Op700 = { "<", ">", "=", "<=", ">=" };

Rule500 = XFY<Op500, Rule400>;
Op500 = { "+", "-" };

Rule400 = XFY<Op400, ExprTerm>;
Op400 = { "*", "/" }

ExprTerm = {
    Number,
    Variable,
    AtomicFunctor,
    Functor,
    List,
    "(" <Expr> ")"
}

AtomicFunctor: Term =
    Atom => Term::Fun( Functor{ name: <>, args: vec![]} );

Functor: Term =
    <i:FunctorName> <arg1:Expr_arg> <mut args:("," <Expr_arg>)*> ")" => {
        args.insert(0, arg1);
        Term::Fun(Functor { name: i, args })
    };

List: Term = {
    "[" "]" => Term::name("[]"),
    "[" <x:Expr_arg> <mut xs:("," <Expr_arg>)*> <tail:("|" <Expr_arg>)?> "]" => {
        let rest = tail.unwrap_or(Term::name("[]"));
        xs.insert(0, x);
        xs.into_iter().fold(rest, |lst, x| {
            Term::functor2("[|]", x, lst)
        })
    }
}

Number: Term = Num => Term::Integer(<>);

FunctorName: Atom = r"[a-z][_A-Za-z0-9]*\(" => Atom(<>.to_string());
Atom: Atom = r"[a-z][_A-Za-z0-9]*" => Atom(<>.to_string());
Variable: Term = r"[_A-Z][_A-Za-z0-9]*" => Term::Var(Variable(<>.to_string(), 0));

Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
