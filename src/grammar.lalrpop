use std::str::FromStr;

use crate::terms;

grammar;

pub Program = Clause*;
pub Clause = <Expr> ".";
pub Query = <Expr> ".";
pub Expr = Rule1200;

XFY<Op,NextTier>: terms::Term = {
    <l:XFY<Op,NextTier>> <op:Op> <r:NextTier> => terms::functor2(op, l, r),
    NextTier
};

Rule1200 = XFY<Op1200, Rule1000>;
Rule1200_arg = XFY<Op1200, Rule1000_arg>;
Op1200 = { ":-" };

Rule1000 = XFY<Op1000, Rule700>;
Rule1000_arg = Rule700;
Op1000 = { "," }

Rule700 = XFY<Op700, Rule500>;
Op700 = { "<", ">", "=", "<=", ">=" };

Rule500 = XFY<Op500, Rule400>;
Op500 = { "+", "-" };

Rule400 = XFY<Op400, Term>;
Op400 = { "*", "/" }

Term = {
    Name,
    Variable,
    AtomicFunctor,
    Functor,
    "(" <Expr> ")"
}

AtomicFunctor: terms::Term =
    Identifier => terms::Term::Functor{ name: <>, args: vec![] };

Functor: terms::Term =
    <i:FunctorName> <args:(<FunctorArg> ","?)+> ")" => terms::Term::Functor { name: i, args: args };

FunctorArg: terms::Term = Rule700;

Name: terms::Term = Num => terms::Term::Integer(<>);

FunctorName: terms::Name = r"[a-z][_A-Za-z0-9]*\(" => terms::Name(<>.to_string());
Identifier: terms::Name = r"[a-z][_A-Za-z0-9]*" => terms::Name(<>.to_string());
Variable: terms::Term = r"[_A-Z][_A-Za-z0-9]*" => terms::Term::Var(terms::Variable(<>.to_string()));

Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
